#!/usr/bin/perl
=pod

SBX chooser

=head1 NAME

  sbx - Tool voor menu-selectie sandboxes.

=head1 DESCRIPTION

Keuze sandbox en het starten van de shell omgeving.

=head1 .sbxconfig

Configuratie file for your shell environment.

vb
   [foo]
      SBX=$HOME/sbx

=over 12

=item C<[item]>

Menu item shortname

=item C<SBX>

    Root of your sandbox
    The 'sb' alias return you to your sandbox.


=back

=head1 LICENSE

=head1 AUTHOR

Hans Mulder - H_Mulder@belastingdienst.nl

=head1 SEE ALSO

=cut

#
# GLOBALS in GLB

my %GLB={
            hostname => 'localhost'
        };
$GLB{hostname}=`hostname`;
$GLB{uname}=`uname`;
chomp $GLB{uname};
chomp $GLB{hostname};
#
#Terminal stuff
#- Prompt
#- Colors
package TERM;
my %color=(
        test => "\e[49;44m",
        bluebackgr => "\e[49;44m",
        yellowbackgr => "\e[49;43m",
        green => "\e[49;32m",
        greenbackgr => "\e[49;42m",
        redbackgr => "\e[49;41m",
        white => "\e[49;37m",
        lblue => "\e[49;36m",
        purple => "\e[49;35m",
        blue => "\e[49;34m",
        yellow => "\e[49;33m",
        red => "\e[49;31m"
        );
sub color_normal()
{
        return '^[[0m';
}
sub prompt()
{
    #export PS1="$(printf "${TITLE}$HOSTNAME:\$PWD>")"
    my $hostname=`hostname`;
    chomp $hostname;
    $ENV{PS1}  ="\\[\033]2;\${USER}@\${HOSTNAME} SBX \${SBX}\007\\]";#TITLE
    $ENV{PS1} .='\\['.$color{yellow}.'\\]'.$hostname.':${PWD} SB'.'\['.$color{white}.'\]'.'>';#path
}

sub title(@)
{
    #print "Set Title\n";
    #print("\e]2;test3\7");
	#print "\033]2;test1\007";
	#print "\033]2;test2\007";
	#print "\c]2;test4\a";

    #system('echo','\033]0;${USER}@${HOST}\007');
    #system('export','SBX=test');
    $ENV{SBX}="@_";
}
#
#Registry stuff
#
package Win;
use Data::Dumper;
#use Win32::Registry;
my $reg='/cygdrive/c/Windows/System32/reg.exe';
#REG QUERY "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /s 
sub Query($)
{
  my $key=shift;
  my $q=$reg.' QUERY "'.$key.'" /s';
  my %keys;
  open(my $fh, '-|', $q) or die $!;
  while (my $l=<$fh>) {
    chomp $l;
    next if not $l =~ m/REG_/;
    #print "DBG:$l\n";
    my ($reg,$type,$val)=split(' ',$l,3);
    #print "DBG:reg $reg,$type,$val\n";
    $val =~ s/\r$//;
    $keys{$reg}= $val;
    #print 'DBG::$keys{'.$reg.'}="'.$val."\"\n";
  }
  close $fh;
	print "DBG:env==>".Dumper(\%keys)."\n";
  return %keys;
}

#
#Windows env is case insensitive
#
sub set_env($$)
{
    my ($env,$val)=@_;
    my $var_set=0;
    foreach( keys %ENV ){
      if(/^$env$/i){
          print "DBG:set $_($env) to '$val'\n";
          $ENV{$_}=$val;
          $var_set=1;
          last;
      }
    }
    $ENV{$env}=$val if not $var_set;
    print "DBG:set $env='$val' and found '$ENV{$env}\n";
}
#
#CONFIG
#
package CONFIG;
use Data::Dumper;

my %CFG=();
sub  trim { my $s = shift; $s =~ s/^\s+|\s+$//g; return $s };
sub import()
{
  my $config_file="$ENV{HOME}/.sbxconfig";
  my $label="global";#default environment
  open CONFIG, $config_file or die "Could not open '$config_file':$!";
  while( <CONFIG> ){
    chomp;
    next if /^#/;#skip comment starting with #
    #$label = s/(^\[)||(\]$)// if /^\[/ ;
    s/[^\\]#.*//;  #strip comment
    if( m/^\[/ ){
      s/(^\[)||(\]$)//g;
      $label=$_;
    };
    if( m/=/ ){
      my ($var,$val)=split(/=/);
      $CFG{$label}{trim $var}= trim $val;
    }
  }
  #
  #print "user_config".Dumper(\%CFG)."\n";
    
  close CONFIG;
}

#
# inject deps into given group
#
sub inject($)
{
  my $item=shift;
  my $grp=$CFG{$item};
  #print "user_config".Dumper($grp)."\n";
  #print "grp is $group ";
  #print "NODEPS $CFG{$grp}{'cfg.deps'}\n" if not $CFG{$grp}{'cfg.deps'};
  return 0 if not $grp->{'cfg.deps'};
  #print "DBG:cfg.deps $grp->{'cfg.deps'}\n";
  my @deps=split /,/, $grp->{'cfg.deps'};
  foreach my $item( @deps ){
      #print "deps = $item\n";
      #print "importing ".Dumper(\%CFG)."\n";
      my $ext_grp=$CFG{$item};
      #print "importing ".Dumper($ext_grp)."\n";
      foreach( keys %$ext_grp ){
	#print "keys = $_\n";
        $grp->{$_}=$ext_grp->{$_};
      }
  }
  #print "importing ".Dumper(\%CFG)."\n";
}

sub get_cfg()
{
  return \%CFG;
}
sub get_group($)
{
  my $group=shift;
  return $CFG{$group};
}

#
#MENU
#
package MENU;
sub get_items()
{
  #TODO filter op menu
  my @items=();
  foreach my $grp ( sort keys %CFG ){
    push @items, $grp if $CFG{$grp}{'cfg.menu'} eq 'true';
  }
  return @items;
}
sub ls()
{
  my @options=get_items();
	my $nr=1;
	#print "user_menu".Dumper(\%menu)."\n";
	foreach(@options){
		print $nr++.") $_ ";
		print ":$CFG{$_}{'cfg.info'}";
		print "\n";
	}
}
sub menu()
{
  my @options=get_items();

  ls();#TODO options meegeven

	my $choice;
	while(1){
        	print "Select one [1..".(scalar @options).']?';
        	$choice=<STDIN>;
		chomp $choice;
		$choice=1 if $choice eq '';#default
		last if $choice > 0 and $choice <= @options ;
	};

	return $options[$choice-1];
}

#
#Environment
#
package ENV;
use Data::Dumper;

#
# substitute %var%  into var
#
sub sub_win_env()
{
  my $found=0;
  do{
    $found=0;
    foreach my $var ( keys %ENV ) {
      #print "DBG:test $var\n";
      if( $ENV{$var} =~ m/\%([^%]*)\%/ ){
          my $varvar=$1;
          if( $ENV{$varvar} ){
            $ENV{$var} =~ s/\%$varvar\%/$ENV{$varvar}/ig;
            #print "DBG:found $varvar=$ENV{$varvar} in new $var=$ENV{$var}\n";
            $found=1;
          }else{
            print "WARNING: no environment var set for $varvar  in $var='$ENV{$var}'\n";
          }
        }
    }
  }while($found);
}

sub export_grp($)
{
  my $group=shift;
  my $env=CONFIG::get_group($group);
  #print "DBG:env".Dumper($env)."\n";
  #TODO mbv export
  foreach( keys %$env ) {
    $ENV{$_}=$env->{$_};
    #print "DBG:export $_, $ENV{$_} to $env->{$_}\n";
  }
}

#
# export hash to environment
#
sub export($)
{
  #print "DBG:env".Dumper(\@_)."\n";
  my $env=shift;
  #print "DBG:env".Dumper($env)."\n";
  #chdir("/tmp/abc");
  foreach( keys %$env ) {
    if( m/^TE{0,1}MP$/
        || m/^HOME$/
      ){
      #TMP en TEMP are prepended by pwd
      print "FOUND TEMP=$_=$ENV{$_},skip\n";
      next;
    }
    #$ENV{$_}=$env->{$_};
    Win::set_env($_,$env->{$_});
    print "DBG:export $_  = $ENV{$_} = $env->{$_}\n";
  }

}
#
#import : environment group
#
sub sub_vars($)
{
  my $group=shift;
  my $env=CONFIG::get_group($group);

  my $found=0;
  do{
    $found=0;
    foreach my $var ( keys %$env ) {
      #$ENV{$_}=$env->{$_};
      #print "DBG:test $var\n";
      if( $env->{$var} =~ m/\$\{([^}]*)\}/ ){
          my $varvar=$1;
          $env->{$var} =~ s/\$\{[^}]*\}/$ENV{$varvar}/ if  $ENV{$varvar};
          #print "DBG:found $varvar, $ENV{$varvar} in \${} in $env->{$var}\n";
          $found=1;
        }
    }
  }while($found);
}
#
# Start shell
# Depends on cfg.type
# sh  : start sh
# cmd : start dos cmd.exe
sub start($)
{
  my $group=shift;
  my $env=CONFIG::get_group($group);
  #TODO start shell
  die "Can not find dir '$ENV{SBXROOT}', verify your SBXROOT?\n" if not -d $ENV{SBXROOT};
  #print "DBG:chdir to '$ENV{SBXROOT}'\n";
  chdir( "$ENV{SBXROOT}" ) or die "$!";
  for( $env->{'cfg.type'} ){
    shell_sh()  if /^sh$/ ;
    shell_dos()  if /^dos$/ ;
    shell_bash()  if /^bash$/ ;
    shell_rlwrap()  if /^rlwrap$/ ;
    system( '/cygdrive/c/Windows/System32/cmd.exe')  if /^cdos$/ ;
    break;
  }
  #print "DBG:chdir( $ENV{SBXROOT} )\n";
  #system('sh');
}

sub get_winpath($)
{
    my $path=shift;
    print "from $path ";
    $path=`/cygdrive/c/ws/cygwin/bin/cygpath -w '$path'`;
    chomp $path;
    print "to '$path' \n";
    return $path;
}
sub set_windows_env()
{
    die "ERR:env USER not set" if not $ENV{USER};
    $ENV{APPDATA}=get_winpath("/Users/$ENV{USER}/AppData/Roaming") if not $ENV{APPDATA};
#< CommonProgramFiles=C:\Program Files\Common Files
    $ENV{'CommonProgramFiles'}=get_winpath("/cygdrive/c/Program Files/Common Files") if not $ENV{'CommonProgramFiles'};
    $ENV{USERPROFILE}=get_winpath("/Users/$ENV{USER}") if not $ENV{USERPROFILE};
    $ENV{LOCALAPPDATA}=get_winpath("/Users/$ENV{USER}/AppData/Local") if not $ENV{LOCALAPPDATA};
    $ENV{USERNAME}=${USER} if not $ENV{USERNAME} = $ENV{USER};

    #TODO tijdelijk env fixes
    delete $ENV{COMSPEC};
    delete $ENV{INFOPATH};
    delete $ENV{LANG};
    delete $ENV{MAIL};
    delete $ENV{MANPATH};
    delete $ENV{LOGNAME};
    delete $ENV{TZ};
    delete $ENV{PROGRAMFILES}; Win::set_env('ProgramFiles','C:\\Program Files');
    delete $ENV{SYSTEMDRIVE}; Win::set_env('SystemDrive','C:');
    delete $ENV{SYSTEMROOT}; Win::set_env('SystemRoot','C:\\Windows');


    $ENV{WinDir}=$ENV{WINDIR};delete $ENV{WINDIR};

    Win::set_env('ComSpec','C:\\Windows\\system32\\cmd.exe');
    #$ENV{'ComSpec'}='C:\\Windows\\system32\\cmd.exe';
    Win::set_env('HOMEDRIVE','N:');
    Win::set_env('HOMEPATH','\\');
    Win::set_env('HOMESHARE','\\\\ob300vfsw12f\\ob300vfsw12f.USR\\muldh23');
    Win::set_env('LOGONSERVER','\\\\OB309VDCW12F');
    Win::set_env('ProgramData','C:\\ProgramData');
    Win::set_env('PSModulePath','C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules\\');
    Win::set_env('PUBLIC','C:\\Users\\Public');
    Win::set_env('SESSIONNAME','Console');
    Win::set_env('USERDNSDOMAIN','ONT.BELASTINGDIENST.NL');
    Win::set_env('USERDOMAIN_ROAMINGPROFILE','ONT');
    Win::set_env('USERDOMAIN=','ONT');



    #undef $ENV{BASH} if defined $ENV{BASH};
    delete $ENV{BASH};
}

sub shell_bash()
{
  if( not $ENV{ENV} and -f "$ENV{SBXROOT}/.sbx_env" ){
	  $ENV{ENV}=$ENV{SBXROOT}.'/.sbx_env';
  }
  $ENV{PS1}='${SBX:+($SBX)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ';
  $ENV{PS1}='\$ ';
  printf "set PS1 in '$ENV{PS1}'\n";
  $ENV{BASH_ENV}=$ENV{ENV};
  $ENV{debian_chroot}=$ENV{SBX};
  system('bash','--rcfile',$ENV{ENV});
}

sub shell_sh()
{
  #set ENV if noet set and files exists
  if( not $ENV{ENV} and -f "$ENV{SBXROOT}/.sbx_env" ){
	  $ENV{ENV}=$ENV{SBXROOT}.'/.sbx_env';
  }
  TERM::prompt();
  system('sh');
}
sub shell_rlwrap()
{
  print "DBG:enter shell_rlwrap()\n";
    my %env=Win::Query( 'HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment');
    my $PATH=$env{Path};
    ENV::export(\%env);
    %env=Win::Query( 'HKCU\Environment');
    $env{Path}=$PATH.';'.$env{Path};
    $env{Path}=~ s/%SystemRoot%/C:\\windows/g;
    ENV::export(\%env);
    set_windows_env();
    ENV::sub_win_env();
    #$SBXROOT="'$SBXROOT'";
    #$SBXROOT=~ s#\\#/#g;
    my $TASTE=`/cygdrive/c/ws/cygwin/bin/cygpath -t unix '$ENV{WTLSBTU_Location}/nt/bin/cmdbox.cmd'`;
    chomp $TASTE;
    my $SBXROOT=`/cygdrive/c/ws/cygwin/bin/cygpath -w '$ENV{SBXROOT}'`;
    chomp $SBXROOT;


    #system('prompt $P$S%SBX%$G');
    #system('rlwrap -pblue -i -S "$(pwd) $SBX: " /cygdrive/c/Windows/System32/cmd.exe');
    my @cmd=('/cygdrive/c/ws/cygwin/bin/rlwrap','-pblue', '-i', '-c',$TASTE, $SBXROOT);
    print "DBG:system(@cmd);\n";
    #system('rlwrap -pblue -i -c '."'$TASTE' $ENV{SBXROOT}") and die "ERR last system call $!";
    system(@cmd) and die "ERR last system call '@cmd' $!";
    print "DBG:return to cygwin\n";
}
sub shell_dos()
{
  print "DBG:enter shell_dos()\n";
    my %env=Win::Query( 'HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment');
    my $PATH=$env{Path};
    ENV::export(\%env);
    %env=Win::Query( 'HKCU\Environment');
    $env{Path}=$PATH.';'.$env{Path};
    ENV::export(\%env);
    set_windows_env();
    ENV::sub_win_env();
    system('/cygdrive/c/Windows/System32/cmd.exe');
}
#
# SBX utilities
#
package SBX;
use Data::Dumper;
sub ls()
{
	print "Sandbox list:\n";
  MENU::ls();
}
sub info()
{
	print "Sandbox '$ENV{SBX}' info:\n";
	print "Doesn't look like a sandbox, environment not set SBX='$ENV{SBX}'\n" if not $ENV{SBX};

	print "Environment:\n";
  CONFIG::import();
  CONFIG::inject($ENV{SBX});
  my $env=CONFIG::get_group($ENV{SBX});
  SBX::print_env(sort keys %$env);
  #foreach my $var( sort keys %$env ) {
  #printf ("%18s = '%s'\n",$var,$env->{$var});
  #}

	if( -e "$ENV{ENV}" ){
		print "INFO from '$ENV{ENV}'\n";
		my @info=grep(!/#INFO_/,`sed -n '/INFO_START/,/INFO_STOP/p' '$ENV{ENV}'`);
		foreach ( @info ){
      print "  $_";
    }
	}
}

#TODO use by info
sub print_env(@)
{
        foreach( @_ ){
                printf ("%18s = %s\n",$_,$ENV{$_}) if $ENV{$_};
        }
}
#TODO use by cfg.deps.tools
sub print_where($)
{
        my $file=shift;
        my $where=`which 2>/dev/null '$file'`;
        chomp $where;
        if ( not -f $where ){
                $where=' - not found or readable';
        }
        printf("%18s =  %s\n",$file,$where);
}
sub start($)
{
  my $SBX=shift;
  $ENV{SBX}=$SBX;
  print "choice=$SBX\n";
  CONFIG::inject($SBX);
  ENV::export_grp($SBX);
  ENV::sub_vars($SBX);
  ENV::export_grp($SBX);
  ENV::start($SBX);
}
#
# MAIN
# 
package MAIN;
use Data::Dumper;

my $test=0;
if($test){
  my %env=Win::Query( 'HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment');
	print "DBG:env==>".Dumper(\%env)."\n";
  print "DBG:stop\n";
  exit 100;
}

#if( $ARGV[0] eq 'info' ){
#	SBX::info();
#	exit 0;
#}

#
# MAIN
# 
#

if( $ENV{SBX} ) {
  print "Inside sandbox! Name is SBX='$ENV{SBX}'\n";
  exit 1;
}

CONFIG::import();
for( $ARGV[0] ){
  chomp;
  print "argv is '$_'\n";
  last if not length $_;
	/^info$/ and do { SBX::info(); exit 0;};
	/^ls$/   and do { SBX::ls()  ; exit 0;}; 
  SBX::start($_);
  exit 0;
}


my $choice=MENU::menu();
SBX::start($choice);
